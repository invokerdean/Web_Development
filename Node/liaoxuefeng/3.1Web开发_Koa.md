## 1.是什么
koa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本。

1. Express是第一代最流行的web框架，它对Node.js的http进行了封装,但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调
2. 随着新版Node.js开始支持ES6，Express的团队又基于ES6的generator重新编写了下一代web框架koa。和Express相比，koa 1.0使用generator实现异步，代码看起来像同步的：
3. koa团队并没有止步于koa 1.0，他们非常超前地基于ES7开发了koa2，和koa 1相比，koa2完全使用Promise并配合async来实现异步。出于兼容性考虑，目前koa2仍支持generator的写法，但下一个版本将会去掉。

## 2.Koa入门
* 安装：
1. 方法一：```C:\...\hello-koa> npm install koa@2.0.0```npm会把koa2以及koa2依赖的所有包全部安装到当前目录的node_modules目录下。

2. 方法二：hello-koa这个目录下创建一个package.json(可以通过npm init创建)，这个文件描述了我们的hello-koa工程会用到哪些包。其中，dependencies描述了我们的工程依赖的包以及版本号。在hello-koa目录下执行npm install就可以把所需包以及依赖包一次性全部装好

> **注意，任何时候都可以直接删除整个node_modules目录，因为用npm install命令可以完整地重新下载所有依赖。并且，这个目录不应该被放入版本控制中。

```
"scripts": {
    "start": "node app.js"
}
```
package.json中如果设置了以上参数，可以用npm start来运行app.js

```javascript
const Koa=require('koa');
const app=new Koa();

//ctx为上下文，是由koa传入的封装了request和response的变量，next为下一步要执行的异步函数
app.use(async (ctx,next)=>{
    await next();
    ctx.response.type='text/html';
    ctx.response.body='<h1>hello koa!</h1>'
})
app.listen(3000);
console.log('app started at port3000')
```
每收到一个http请求，koa就会调用通过app.use()注册的async函数，并传入ctx和next参数。koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合成为处理链，完成很多有用的功能。
> **调用app.use()的顺序决定了middleware的顺序，如果一个middleware没有调用await next()，后续的middleware将不再执行了。
```JavaScript
app.use(async(ctx,next)=>{
  if(await checkUserPermission()){
    await next();
  }else{
    ctx.response.status=403;
  }
})
```

## 3.处理URL
正常情况下，我们应该对不同的URL调用不同的处理函数，这样才能返回不同的结果。需要有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数，这样，我们才能专心为每个URL编写处理函数。

由上可知，我们需要引入koa-router这个middleware，让它负责处理URL映射。
#### GET请求
```JavaScript
const Koa=require('koa');
//require('koa-router')返回的是函数:
const router=require('koa-router')();

const app=new Koa();

app.use(async (ctx,next)=>{
    console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
    await next();
})

//注册一个GET请求
router.get('/hello/:name',async(ctx)=>{
    var name=ctx.params.name;
    ctx.response.body=`<h1>hello ${name}!</h1>`;
})

router.get('/',async(ctx,next)=>{
    ctx.response.body='<h1>index</h1>'
})

//添加路由中间件
app.use(router.routes());

app.listen(3000);
console.log('app started at port3000')
```
#### POST请求
post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都**不提供**解析request的body的功能。**所以，我们又需要引入另一个middleware，koa-bodyparser来解析原始request请求，然后，把解析后的参数，绑定到ctx.request.body中。**
> middleware的顺序很重要，这个koa-bodyparser必须在router之前被注册到app对象上。
```javascript
const Koa=require('koa');
const router=require('koa-router')();
const bodyParser=require('koa-bodyparser');

const app=new Koa();

app.use(async (ctx,next)=>{
    console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
    await next();
})

app.use(bodyParser());

router.get('/hello/:name',async(ctx)=>{
    var name=ctx.params.name;
    ctx.response.body=`<h1>hello ${name}!</h1>`;
})

router.get('/',async(ctx,next)=>{
    ctx.response.body=`<h1>index</h1>
        <form action='/signIn' method='post'>
            <p>Name:<input name='name' value='koa'></p>
            <p>Password:<input name='password' type='password'></p>
            <p><input type='submit' value='submit'></p>
        </form>`
});

router.post('/signIn',async(ctx,next)=>{
    var
        name=ctx.request.body.name||'';
        password=ctx.request.body.password||'';
    console.log(`sign in with name:${name},password:${password}`);
    if(name==='koa'&&password==='12345'){
        ctx.response.body=`<h1>Welcome ${name}!</h1>`
    }else{
        ctx.response.body=`<h1>login failed!</h1>
            <p><a href='/'>try again</p>`;
    }
});

app.use(router.routes());

app.listen(3000);
console.log('app started at port3000')
```
#### 重构
把所有url处理函数都放在入口文件中会使得工程冗余凌乱，因此考虑代码分离，把URL处理函数集中到某几个js文件中，然后让app.js自动导入处理URL的函数
```
+- controllers/
|  |
|  +- login.js <-- 处理login相关URL
|  |
|  +- users.js <-- 处理用户管理相关URL
|
+- app.js <-- 使用koa的js
```
