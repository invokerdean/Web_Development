#### 基本概念
Cross-Site Request Forgery跨站请求伪造。主要指攻击者通过设置好的陷阱，盗用已完成认证的用户身份，以其名义发送恶意请求状态更新，造成隐私泄露和财产安全。属于因会话管理疏忽引发的安全漏洞。
![avatar](https://user-gold-cdn.xitu.io/2017/10/11/ea16ef6642f4e35b5beca485a8847781?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 影响
1. 利用认证用户权限更新设定信息
2. 利用认证用户权限购买商品
3. 利用认证用户权限发布言论

#### 实现
攻击者设置好陷阱，一旦用户访问就会发送“在留言板上发表xxx言论的评论”的请求。用户通过认证后，浏览器的cookie中持有会话id，访问该页面时执行了请求，不知情地发表了评论。

#### 与XSS区别
1. 通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为      XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。

2. 本质上讲，XSS 是代码注入问题，CSRF 是 HTTP 问题。XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面。

#### 防御
1. 验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差。

2. 尽量使用 post ，限制 get 使用；上一个例子可见，get 太容易被拿来做 csrf 攻击，但是 post 也并不是万无一失，攻击者只需要构造一个form就可以。

3. Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。

4. token；token 验证的 CSRF 防御机制是公认最合适的方案。
>第一步：后端随机产生一个 token，把这个token 保存到 session 状态中；同时后端把这个token 交给前端页面；第二步：前端页面提交请求时，把 token 加入到请求数据或者头信息中，一起传给后端；后端验证前端传来的 token 与 session 是否一致，一致则合法，否则是非法请求。若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。

