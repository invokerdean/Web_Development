#### 基本概念
Cross-Site Request Forgery跨站请求伪造。主要指攻击者通过设置好的陷阱，盗用已完成认证的用户身份，以其名义发送恶意请求状态更新，造成隐私泄露和财产安全。属于因会话管理疏忽引发的安全漏洞。
![avatar](https://user-gold-cdn.xitu.io/2017/10/11/ea16ef6642f4e35b5beca485a8847781?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

> CSRF 攻击时源于 WEB 的隐式身份验证机制！WEB 的身份验证机制虽然可以保证一个请求是来自某个用户的浏览器，但无法保证该请求是经过用户批准发送的。

#### 影响
1. 利用认证用户权限更新设定信息
2. 利用认证用户权限购买商品
3. 利用认证用户权限发布言论

#### 实现
攻击者设置好陷阱，一旦用户访问就会发送“在留言板上发表xxx言论的评论”的请求。用户通过认证后，浏览器的cookie中持有会话id，访问该页面时执行了请求，不知情地发表了评论。

#### 与XSS区别
1. 通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为      XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。

2. 本质上讲，XSS 是代码注入问题，CSRF 是 HTTP 问题。XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面。

#### 防御
1. 验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差。

2. 尽量使用 post ，限制 get 使用；上一个例子可见，get 太容易被拿来做 csrf 攻击，但是 post 也并不是万无一失，攻击者只需要构造一个form就可以。

3. Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。
> 常见的互联网页面与页面之间是存在联系的，比如你在 腾讯首页 应该找不到通往 http://www.facebook.com 的链接的，比如你在某论坛留言，那么不管你留言之后重定向到哪里，之前的网址一定保留在新页面中 Referer 属性中。通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都接受到 Referer 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击。

4. token；token 验证的 CSRF 防御机制是公认最合适的方案。
>第一步：后端随机产生一个 token，把这个token 保存到 session 状态中；同时后端把这个token 交给前端页面；第二步：前端页面提交请求时，把 token 加入到请求数据或者头信息中，一起传给后端；后端验证前端传来的 token 与 session 是否一致，一致则合法，否则是非法请求。若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。

CSRF 攻击要成功的条件在于攻击者能够准确地预测所有的参数从而构造出合法的请求，所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击，可以保存其原有参数不变，另外添加一个参数 Token，其值是随机的，这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击，所以我们在构造请求时候只需要保证：
* Token 要足够随机，使攻击者无法准确预测
* Token 是一次性的，即每次请求成功后要更新 Token，增加预测难度
* Token 要主要保密性，敏感操作使用 POST，防止 Token 出现在 URL 中
