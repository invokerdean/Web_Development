#### 3.1函数中的作用域
属于这个函数的全部变量都可以在整个函数的范围内使用及复用（包括嵌套的作用域）

#### 3.2隐藏内部实现
用函数声明对代码片段进行包装：
1. 基于最小暴露原则，保证安全性
2. 规避同名标识符的冲突
>例如，加载第三方库时（尤其是多个时），需要将内部变量和方法隐藏避免冲突，一种常用的做法是声明一个对象作为命名空间，所有需要暴露的变量和方法作为该对象的属性；另一种做法是采用模块管理器，将库的标识符显示地导入另一个特定作用域(见作用域闭包篇)


#### 3.3函数作用域
* 区别函数声明和函数表达式的最简单方法是看function关键字的位置，如果是声明的第一个词，即为函数声明，否则是函数表达式
```(function foo(){...})```foo被绑定在函数表达式自身的函数中，即只能在...中被访问，外部作用域则不行

```
   (function foo(){...})()
   (function foo(){...}())
```
第一个()将函数表达式,第二个()执行了这个函数，立即执行函数表达式也可以传递参数

> IIFE函数应用之一是用于修正undefined值被异常覆盖的场景（少见），通过(function foo(undefined){})()即可在代码块中安全访问undefined

>另一应用是调换代码运行顺序，例如
```
(function IIFE(def){
    def();
})(function def(){
    console.log('a');
})//a
def();//Uncaught ReferenceError: def is not defined
```

#### 3.4块作用域
1. with是块作用域的一个例子（从对象中创建的块作用域仅在with声明中有效）
> 'with'语句將某个对象添加到作用域链的顶部，如果在statement中有某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值。如果沒有同名的属性，则将拋出ReferenceError异常。

2. try/catch(ES3)的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效
```
try{
   undefined();
}catch(err){
   console.log(err);//TypeError: undefined is not a function
}
console.log(err);//ReferenceError: err is not defined
```
3. let关键字将变量绑定到任意作用域中，通常是{...}内部，即隐式劫持了所在作用域
>可以通过在内部{...}显式创建块，来避免对外部块的影响;let没有变量提升，声明的代码在运行前并不存在

>应用：gc（垃圾收集中），由于事件监听的回调函数会产生一个覆盖全局的闭包，保留全局变量，因此会阻碍垃圾收集，可以将需要回收的变量用{...}包裹

4. const也可以创建块作用域
>其值是固定的，任何修改值的操作都会引起错误




